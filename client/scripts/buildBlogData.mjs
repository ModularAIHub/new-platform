import { mkdirSync, readdirSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, extname, resolve } from 'node:path';

const BLOG_BASE_URL = 'https://suitegenie.in';

const rootDir = process.cwd();
const contentRoot = resolve(rootDir, 'content', 'blog');
const categoriesPath = resolve(contentRoot, 'categories.json');
const postsRoot = resolve(contentRoot, 'posts');

const generatedIndexPath = resolve(rootDir, 'src', 'data', 'blogIndex.generated.js');
const publicBlogRoot = resolve(rootDir, 'public', 'blog');
const publicPostsRoot = resolve(publicBlogRoot, 'posts');
const publicIndexPath = resolve(publicBlogRoot, 'index.json');
const publicSearchIndexPath = resolve(publicBlogRoot, 'search-index.json');
const sitemapOutputPath = resolve(rootDir, 'public', 'sitemap-blog.xml');

const readJson = (filePath) => JSON.parse(readFileSync(filePath, 'utf8'));

const collectJsonFiles = (dirPath) => {
  const entries = readdirSync(dirPath, { withFileTypes: true });
  const files = [];

  for (const entry of entries) {
    const fullPath = resolve(dirPath, entry.name);

    if (entry.isDirectory()) {
      files.push(...collectJsonFiles(fullPath));
      continue;
    }

    if (entry.isFile() && extname(entry.name).toLowerCase() === '.json') {
      files.push(fullPath);
    }
  }

  return files;
};

const stripMarkdown = (value = '') =>
  String(value)
    .replace(/```[\s\S]*?```/g, ' ')
    .replace(/`[^`]+`/g, ' ')
    .replace(/!\[.*?\]\(.*?\)/g, ' ')
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
    .replace(/[*_>#-]/g, ' ')
    .replace(/\|/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

const generateBlogSitemapXml = (posts = [], baseUrl = BLOG_BASE_URL) => {
  const publishedPosts = posts.filter((post) => post.status === 'published');
  const seenUrls = new Set();

  const lines = [
    '<?xml version="1.0" encoding="UTF-8"?>',
    '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">',
  ];

  for (const post of publishedPosts) {
    const canonical = post.seo?.canonicalUrl || `${baseUrl}/blogs/${post.category}/${post.slug}`;
    if (seenUrls.has(canonical)) continue;
    seenUrls.add(canonical);
    const lastmod = new Date(post.lastModified || post.publishDate).toISOString().slice(0, 10);

    lines.push('  <url>');
    lines.push(`    <loc>${canonical}</loc>`);
    lines.push(`    <lastmod>${lastmod}</lastmod>`);
    lines.push('    <changefreq>weekly</changefreq>');
    lines.push('    <priority>0.9</priority>');
    lines.push('  </url>');
  }

  lines.push('</urlset>');
  return lines.join('\n');
};

const categoriesPayload = readJson(categoriesPath);
const blogCategoryMeta = categoriesPayload.meta || {};
const blogCategoryOrder = categoriesPayload.order || [];

const postFiles = collectJsonFiles(postsRoot);
if (!postFiles.length) {
  throw new Error(`No blog post files found in ${postsRoot}`);
}

const seenRouteKeys = new Set();
const posts = postFiles
  .map((filePath) => readJson(filePath))
  .map((post) => {
    if (!post?.category || !post?.slug) {
      throw new Error(`Invalid post file. Missing category or slug for post id: ${post?.id || 'unknown'}`);
    }

    const routeKey = `${post.category}/${post.slug}`;
    if (seenRouteKeys.has(routeKey)) {
      throw new Error(`Duplicate blog route detected: ${routeKey}`);
    }
    seenRouteKeys.add(routeKey);

    return post;
  })
  .sort((a, b) => new Date(b.publishDate).getTime() - new Date(a.publishDate).getTime());

const postIndex = posts.map((post) => ({
  id: post.id,
  title: post.title,
  slug: post.slug,
  category: post.category,
  tags: post.tags || [],
  excerpt: post.excerpt || '',
  featuredImage: post.featuredImage || null,
  author: post.author || null,
  publishDate: post.publishDate,
  lastModified: post.lastModified || post.publishDate,
  readTime: post.readTime || null,
  featured: Boolean(post.featured),
  status: post.status || 'draft',
  contentPath: `/blog/posts/${post.category}/${post.slug}.json`,
}));

const searchIndex = posts.map((post) => ({
  id: post.id,
  category: post.category,
  slug: post.slug,
  content: stripMarkdown(post.content || '').toLowerCase(),
}));

const generatedModule = `// Auto-generated by scripts/buildBlogData.mjs. Do not edit manually.\n\nexport const BLOG_CATEGORY_META = ${JSON.stringify(blogCategoryMeta, null, 2)};\n\nexport const BLOG_CATEGORY_ORDER = ${JSON.stringify(blogCategoryOrder, null, 2)};\n\nexport const BLOG_POSTS_INDEX = ${JSON.stringify(postIndex, null, 2)};\n\nexport const getPublishedBlogPosts = () =>\n  BLOG_POSTS_INDEX.filter((post) => post.status === 'published').sort(\n    (a, b) => new Date(b.publishDate).getTime() - new Date(a.publishDate).getTime()\n  );\n`;

mkdirSync(dirname(generatedIndexPath), { recursive: true });
writeFileSync(generatedIndexPath, generatedModule, 'utf8');

mkdirSync(publicPostsRoot, { recursive: true });

for (const post of posts) {
  const outputPath = resolve(publicPostsRoot, post.category, `${post.slug}.json`);
  mkdirSync(dirname(outputPath), { recursive: true });
  writeFileSync(outputPath, `${JSON.stringify(post, null, 2)}\n`, 'utf8');
}

const publicIndexPayload = {
  generatedAt: new Date().toISOString(),
  categories: {
    meta: blogCategoryMeta,
    order: blogCategoryOrder,
  },
  posts: postIndex,
};

writeFileSync(publicIndexPath, `${JSON.stringify(publicIndexPayload, null, 2)}\n`, 'utf8');
writeFileSync(publicSearchIndexPath, `${JSON.stringify(searchIndex)}\n`, 'utf8');

const sitemapXml = generateBlogSitemapXml(posts, BLOG_BASE_URL);
writeFileSync(sitemapOutputPath, `${sitemapXml}\n`, 'utf8');

console.log(`Generated blog index (${postIndex.length} posts) at ${generatedIndexPath}`);
console.log(`Generated blog payloads at ${publicPostsRoot}`);
console.log(`Generated search index at ${publicSearchIndexPath}`);
console.log(`Generated sitemap at ${sitemapOutputPath}`);

